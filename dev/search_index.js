var documenterSearchIndex = {"docs":
[{"location":"#FiniteElementQuadratureRules","page":"Home","title":"FiniteElementQuadratureRules","text":"Documentation for FiniteElementQuadratureRules.\n\n","category":"section"},{"location":"#Base.Dict","page":"Home","title":"Base.Dict","text":"Dict(qr::QuadratureRule, ref::String = \"unknown\")\n\nConvert the given QuadratureRule into a Dict for exporting into a YAML file. The optional parameter ref refers to a bibtex key used to reference a publication where the quadrature rule is extracted from.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.AffineGeometry","page":"Home","title":"FiniteElementQuadratureRules.AffineGeometry","text":"AffineGeometry{Ω,mydim,cdom,T} <: AbstractGeometry\n\nAn AffineGeometry is a parametrization using an affine map of the form x → A*x + b. As an AbstractGeometry it is itself a mapping.\n\nExample:\n\ngeo = AffineGeometry(ReferenceElement(Triangle()), [x0,x1,x2])\n@assert domaintype(geo) == Triangle()\nx = geo(λ)    # given λ in coordinates of the reference element\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.AffineGeometry-Tuple{AbstractVector}","page":"Home","title":"FiniteElementQuadratureRules.AffineGeometry","text":"(geo::AffineGeometry)(λ::AbstractVector)\n\nEvaluate the affine geometry mapping geo in the reference element coordinate λ.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.BarycentricMonomials","page":"Home","title":"FiniteElementQuadratureRules.BarycentricMonomials","text":"BarycentricMonomials <: Function\n\nA representation of a multi-dimensional monomial basis function of the form λ[1]^α[1] * λ[2]^α[2] * ... with λ the barycentric coordinate vector and α the exponents associated to the components of the coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.BarycentricMonomials-Union{Tuple{AbstractVector}, Tuple{dim}} where dim","page":"Home","title":"FiniteElementQuadratureRules.BarycentricMonomials","text":"(m::BarycentricMonomials)(λ::AbstractVector)\n\nEvaluate the monomial basis function m in a given barycentric coordinate λ, i.e., compute λ -> λ[1]^α[1] * λ[2]^α[2] * ...\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.CompactQuadratureRule","page":"Home","title":"FiniteElementQuadratureRules.CompactQuadratureRule","text":"CompactQuadratureRule{T,Ω}\n\nA compact (quadrature) rule is defined in terms of a vector of symmetry orbits and their corresponding arguments, which allows to generate a list of quadrature points in the reference element and also their corresponding quadrature weights.\n\nThe rule is defined on a domain, e.g., a triangle or quad, has an expected degree, which means the maximal polynomial degree up to which the quadrature rule is exact.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.CompactQuadratureRule-Tuple{Dict}","page":"Home","title":"FiniteElementQuadratureRules.CompactQuadratureRule","text":"CompactQuadratureRule(data::Dict)\n\nConstruct a CompactQuadratureRule from parsed YAML/Dict data using Float64.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.CompactQuadratureRule-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T<:Real","page":"Home","title":"FiniteElementQuadratureRules.CompactQuadratureRule","text":"CompactQuadratureRule(::Type{T}, data::Dict)\n\nConstruct a CompactQuadratureRuleWithWeights from a YAML/Dict of strings and string arrays. This is a convenience constructor typically used when reading a quadrature rule from a YAML file. All information is encoded in the Dict, in particular the fields\n\ndim and region: characterizing the domain\ndegree: the quadrature degree\norbits: the symmetry orbits\npositions or arguments: representing the arguments to the symmetry orbits\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","page":"Home","title":"FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","text":"CompactQuadratureRuleWithWeights{T,Ω}\n\nA compact (quadrature) rule with weights is defined in terms of a vector of symmetry orbits, their corresponding arguments, and a list of associated weights. This allows to generate a list of quadrature points in the reference element.\n\nThe rule is defined on a domain, e.g., a triangle or quad, has an expected degree, which means the maximal polynomial degree up to which the quadrature rule is exact.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights-Tuple{Dict}","page":"Home","title":"FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","text":"CompactQuadratureRuleWithWeights(data::Dict)\n\nConstruct a CompactQuadratureRuleWithWeights from parsed YAML/Dict data using Float64.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"Home","title":"FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","text":"CompactQuadratureRuleWithWeights(::Type{T}, data::Dict)\n\nConstruct a CompactQuadratureRuleWithWeights from a YAML/Dict of strings and string arrays. This is a convenience constructor typically used when reading a quadrature rule from a YAML file. All information is encoded in the Dict, in particular the fields\n\ndim and region: characterizing the domain\ndegree: the quadrature degree\norbits: the symmetry orbits\npositions: representing the arguments to the symmetry orbits\nweights: for the quadrature weights\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet{Ω<:AbstractDomain,R<:Real}\n\nA JacobiPolySet represents a set of polynomials on a domain Ω in terms of a set of basis polynomials, hereby given as Jacobi polynomials. As an AbstractPolySet it provides also the integral values over the domain of all basis functions.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Tuple{AbstractDomain, Integer}","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(domain::AbstractDomain, degree::Integer)\n\nConstruct a JacobiPolySet on the given domain of given polynomial degree, with Float64 as data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Hexahedron, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Hexahedron, degree::Integer)\n\nConstruct a JacobiPolySet on the Hexahedron domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Line, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Line, degree::Integer)\n\nConstruct a JacobiPolySet on the Line domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Prism, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Prism, degree::Integer)\n\nConstruct a JacobiPolySet on the Prism domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Pyramid, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Pyramid, degree::Integer)\n\nConstruct a JacobiPolySet on the Pyramid domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Quadrilateral, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Quadrilateral, degree::Integer)\n\nConstruct a JacobiPolySet on the Quadrilateral domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Tetrahedron, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Tetrahedron, degree::Integer)\n\nConstruct a JacobiPolySet on the Tetrahedron domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.JacobiPolySet-Union{Tuple{T}, Tuple{Type{T}, Triangle, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type{T}, domain::Triangle, degree::Integer)\n\nConstruct a JacobiPolySet on the Triangle domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.LagrangePolySet","page":"Home","title":"FiniteElementQuadratureRules.LagrangePolySet","text":"LagrangePolySet{Ω<:AbstractDomain,R<:Real}\n\nA LagrangePolySet represents a set of polynomials on a domain Ω in terms of a set of basis polynomials, hereby given as Lagrange polynomials. As an AbstractPolySet it provides also the integral values over the domain of all basis functions.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.LagrangePolySet-Tuple{AbstractDomain, Integer}","page":"Home","title":"FiniteElementQuadratureRules.LagrangePolySet","text":"LagrangePolySet(domain::AbstractDomain, degree::Integer)\n\nConstruct a LagrangePolySet on the given domain of given polynomial degree, with Float64 as data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.LagrangePolySet-Union{Tuple{T}, Tuple{Type{T}, AbstractDomain, Integer}} where T","page":"Home","title":"FiniteElementQuadratureRules.LagrangePolySet","text":"LagrangePolySet(::Type{T}, domain::AbstractDomain, degree::Integer)\n\nConstruct a LagrangePolySet on a given domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.MonomialPolySet","page":"Home","title":"FiniteElementQuadratureRules.MonomialPolySet","text":"MonomialPolySet{Ω<:AbstractDomain,R<:Real}\n\nA MonomialPolySet represents a set of polynomials on a domain Ω in terms of a set of basis polynomials, hereby given as a monomial basis. As an AbstractPolySet it provides also the integral values over the domain of all basis functions.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.MonomialPolySet-Tuple{AbstractDomain, Integer}","page":"Home","title":"FiniteElementQuadratureRules.MonomialPolySet","text":"MonomialPolySet(domain::AbstractDomain, degree::Integer)\n\nConstruct a MonomialPolySet on the given domain of given polynomial degree, with Float64 as data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.MonomialPolySet-Union{Tuple{T}, Tuple{Type{T}, AbstractSimplex, Integer}} where T<:Real","page":"Home","title":"FiniteElementQuadratureRules.MonomialPolySet","text":"MonomialPolySet(::Type{T}, domain::AbstractSimplex, degree::Integer)\n\nConstruct a MonomialPolySet on a simplex domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.MultiLinearGeometry","page":"Home","title":"FiniteElementQuadratureRules.MultiLinearGeometry","text":"MultiLinearGeometry{T,cdim,Ω} <: AbstractGeometry\n\nA MultiLinearGeometry is a geometry mapping defined in terms of linear Lagrange basis function associated to the domain Ω. It can be constructed from a reference element and a vector of corner coordinates.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.MultiLinearGeometry-Tuple{AbstractVector}","page":"Home","title":"FiniteElementQuadratureRules.MultiLinearGeometry","text":"(geo::MultiLinearGeometry)(λ::AbstractVector)\n\nEvaluate the multilinear geometry mapping geo in the reference element coordinates λ, by linear combination of the associated Lagrange basis functions and corner vertices.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.MultiLinearGeometry-Union{Tuple{T}, Tuple{cdim}, Tuple{Ω}, Tuple{ReferenceElement{Ω}, Array{StaticArraysCore.SVector{cdim, T}, 1}}} where {Ω<:AbstractSimplex, cdim, T<:Real}","page":"Home","title":"FiniteElementQuadratureRules.MultiLinearGeometry","text":"MultiLinearGeometry(ref::ReferenceElement, coordVector::AbstractVector)\n\nConstruct a MultiLinearGeometry as an affine geometry if the domain is a simplex.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.QuadratureRule","page":"Home","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule{Ω,T,Point}\n\nA QuadratureRule on a given domain Ω is a collection of points {xᵢ} in the associated reference element and weights {wᵢ}, such that for a given polynomial p the quadrature formula ∑ᵢ p(xᵢ) wᵢ = ∫p(x) dΩ is exact, up to polynomials of a certain degree.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.QuadratureRule-Tuple{Dict}","page":"Home","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(data::Dict)\n\nConstruct a QuadratureRule from parsed YAML/Dict data using Float64.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.QuadratureRule-Union{Tuple{Point}, Tuple{AbstractDomain, Integer, Vector{Point}}} where Point<:(AbstractVector)","page":"Home","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(domain::AbstractDomain, degree::Integer, points::Vector)\n\nConstruct a new QuadratureRule and compute the weights and properties of the rule automatically.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.QuadratureRule-Union{Tuple{T}, Tuple{Point}, Tuple{AbstractDomain, Integer, Vector{Point}, Vector{T}}} where {Point<:(AbstractVector), T<:Real}","page":"Home","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(domain::AbstractDomain, degree::Integer, points::Vector, weights::Vector)\n\nConstruct a new QuadratureRule and compute the properties of the rule automatically.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.QuadratureRule-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"Home","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(::Type{T}, data::Dict)\n\nConstruct a QuadratureRule from a YAML/Dict of strings and string arrays. This is a convenience constructor typically used when reading a quadrature rule from a YAML file. All information is encoded in the Dict, in particular the fields\n\ndim and region: characterizing the domain\ndegree: the quadrature degree\ncoordinates: representing the quadrature points\nweights: for the quadrature weights\nproperties: characterizing properties of the quadrature rule\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.ReferenceElement","page":"Home","title":"FiniteElementQuadratureRules.ReferenceElement","text":"ReferenceElement{Ω,Point}\n\nA reference representation of a given domain Ω in terms of corner coordinates and a list of facets connecting the corners.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules.barycentricCoordinates-Tuple{AbstractDomain, AbstractVector}","page":"Home","title":"FiniteElementQuadratureRules.barycentricCoordinates","text":"barycentricCoordinates(domain::AbstractDomain, x::AbstractVector)\n\nTransform reference element coordinates in a given domain into barycentric coordinates. This is in particular useful for simplex domains where these two coordinates differ. Also for prisms and pyramids where some coordinates parts are associated to a conical extension.\n\nParameters:\n\ndomain::AbstractDomain: The domain of the original coordinates\nx::AbstractVector: The coordinates in the reference domain\n\nResult: Barycentric coordinates associated to the domain.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.expand-Union{Tuple{CompactQuadratureRuleWithWeights{Ω, T}}, Tuple{T}, Tuple{Ω}} where {Ω<:AbstractDomain, T<:Real}","page":"Home","title":"FiniteElementQuadratureRules.expand","text":"expand(cqr::CompactQuadratureRuleWithWeights{Ω,T})\n\nExpand a compact rule into a full quadrature rule. This first expands the symmetry orbits to generate a list of quadrature points and combines it with the given quadrature weights.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.expand-Union{Tuple{CompactQuadratureRule{Ω, T}}, Tuple{T}, Tuple{Ω}} where {Ω<:AbstractDomain, T<:Real}","page":"Home","title":"FiniteElementQuadratureRules.expand","text":"expand(cqr::CompactQuadratureRule{Ω,T})\n\nExpand a compact rule into a full quadrature rule. This first expands the symmetry orbits to generate a list of quadrature points and then computes the associated quadrature weights.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.getProperties-Tuple{AbstractDomain, AbstractVector, AbstractVector}","page":"Home","title":"FiniteElementQuadratureRules.getProperties","text":"getProperties(domain::AbstractDomain, points::AbstractVector, weights::AbstractVector)\n\nCollect properties of a quadrature given as vector of points and weights. Currently, three properties are checked:\n\npositive weights: property :positive\npoints strictly inside the domain: property :inside\npoints are inside or on the boundary of the domain: property :boundary\n\nThe function returns a vector of properties as corresponding Symbols.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.getProperties-Tuple{QuadratureRule}","page":"Home","title":"FiniteElementQuadratureRules.getProperties","text":"getProperties(qr::QuadratureRule)\n\nCollect properties of a quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.getWeights-Union{Tuple{P}, Tuple{AbstractDomain, Integer, AbstractVector{P}, AbstractVector}} where P<:(AbstractVector)","page":"Home","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector, orbits::AbstractVector)\n\nCompute the quadrature weight using Float64 precision.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.getWeights-Union{Tuple{P}, Tuple{AbstractDomain, Integer, AbstractVector{P}}} where P<:(AbstractVector)","page":"Home","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector)\n\nCompute the quadrature weight using Float64 precision.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.getWeights-Union{Tuple{T}, Tuple{Type{T}, AbstractDomain, Integer, AbstractVector, AbstractVector}} where T<:Real","page":"Home","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector, orbits::AbstractVector)\n\nCompute the quadrature weight associated to given quadrature points for quadrature in a given domain, such that polynomial up to degree are integrated exactly. This overload takes into account that the points are associated to symmetry orbits and thus points in the same orbit share a quadrature weight. This makes the computation more stable and faster. The parameter T represents the number type to be used for the computation.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.getWeights-Union{Tuple{T}, Tuple{Type{T}, AbstractDomain, Integer, AbstractVector}} where T<:Real","page":"Home","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector)\n\nCompute the quadrature weight associated to given quadrature points for quadrature in a given domain, such that polynomial up to degree are integrated exactly. The parameter T represents the number type to be used for the computation.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.integrate-Tuple{Function, QuadratureRule}","page":"Home","title":"FiniteElementQuadratureRules.integrate","text":"integrate(f::Function, qr::QuadratureRule)\n\nCompute the integral ∫f(x)dx over a domain Ω=domain(qr) using a quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.integrate-Union{Tuple{dim}, Tuple{FiniteElementQuadratureRules.BarycentricMonomials{dim}, AbstractSimplex}} where dim","page":"Home","title":"FiniteElementQuadratureRules.integrate","text":"integrate(m::BarycentricMonomials, Ω::AbstractSimplex)\n\nCompute the integral of a barycentric monomial m over a generic simplex of volume 1. For a specific simplex, this integral needs to be scaled with its volume.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.optimize-Tuple{CompactQuadratureRuleWithWeights}","page":"Home","title":"FiniteElementQuadratureRules.optimize","text":"optimize(qr::CompactQuadratureRuleWithWeights)\n\nOptimize the position of the quadrature points given as symmetric orbits in the compact rule, by minimizing the quadrature residual on a set of polynomial basis functions. We use basis functions and their integrals given by a JacobiPolySet.\n\n\n\n\n\n","category":"method"},{"location":"#FiniteElementQuadratureRules.optimize-Tuple{CompactQuadratureRule}","page":"Home","title":"FiniteElementQuadratureRules.optimize","text":"optimize(qr::CompactQuadratureRule)\n\nOptimize the position of the quadrature points given as symmetric orbits in the compact rule, by minimizing the quadrature residual on a set of polynomial basis functions. We use basis functions and their integrals given by a JacobiPolySet.\n\n\n\n\n\n","category":"method"}]
}
