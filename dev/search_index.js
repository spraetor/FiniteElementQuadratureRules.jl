var documenterSearchIndex = {"docs":
[{"location":"api/#FiniteElementQuadratureRules","page":"API","title":"FiniteElementQuadratureRules","text":"Documentation for FiniteElementQuadratureRules.\n\n\n\nFunctions exported from FiniteElementQuadratureRules:\n\nTypes in module FiniteElementQuadratureRules:","category":"section"},{"location":"api/#Base.position-Union{Tuple{P}, Tuple{Ω}, Tuple{ReferenceElement{Ω, P}, Integer, Integer}} where {Ω<:AbstractDomain, P}","page":"API","title":"Base.position","text":"position(ref::ReferenceElement{Ω,P}, i::Integer, c::Integer)\n\nCompute the center of the ith sub-entity of codimension c of the reference element ref.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.barycentricCoordinates-Tuple{AbstractDomain, AbstractVector}","page":"API","title":"FiniteElementQuadratureRules.barycentricCoordinates","text":"barycentricCoordinates(domain::AbstractDomain, x::AbstractVector)\n\nTransform reference element coordinates in a given domain into barycentric coordinates. This is in particular useful for simplex domains where these two coordinates differ. Also for prisms and pyramids where some coordinates parts are associated to a conical extension.\n\nParameters:\n\ndomain::AbstractDomain: The domain of the original coordinates\nx::AbstractVector: The coordinates in the reference domain\n\nResult: Barycentric coordinates associated to the domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.checkInside","page":"API","title":"FiniteElementQuadratureRules.checkInside","text":"checkInside(ref::ReferenceElement, x::AbstractVector, tol::Real)\n\nCheck whether a point x lies inside the reference element ref or on its boundary. This check is performed with a given tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#FiniteElementQuadratureRules.checkInside-Union{Tuple{T}, Tuple{ReferenceElement, AbstractVector{T}}} where T<:Real","page":"API","title":"FiniteElementQuadratureRules.checkInside","text":"checkInside(ref::ReferenceElement, x::AbstractVector{T})\n\nCheck whether a point x lies inside the reference element ref or on its boundary. This check is performed with a tolerance tol=eps(T).\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.checkStrictlyInside","page":"API","title":"FiniteElementQuadratureRules.checkStrictlyInside","text":"checkStrictlyInside(ref::ReferenceElement, x::AbstractVector, tol::Real)\n\nCheck whether a point x lies strictly inside the reference element ref. This check is performed with a given tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#FiniteElementQuadratureRules.checkStrictlyInside-Union{Tuple{T}, Tuple{ReferenceElement, AbstractVector{T}}} where T<:Real","page":"API","title":"FiniteElementQuadratureRules.checkStrictlyInside","text":"checkStrictlyInside(ref::ReferenceElement, x::AbstractVector{T})\n\nCheck whether a point x lies strictly inside the reference element ref. This check is performed with a tolerance tol=eps(T).\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.expand-Union{Tuple{CompactQuadratureRuleWithWeights{Ω, T}}, Tuple{T}, Tuple{Ω}} where {Ω<:AbstractDomain, T<:Real}","page":"API","title":"FiniteElementQuadratureRules.expand","text":"expand(cqr::CompactQuadratureRuleWithWeights{Ω,T})\n\nExpand a compact rule into a full quadrature rule. This first expands the symmetry orbits to generate a list of quadrature points and combines it with the given quadrature weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.expand-Union{Tuple{CompactQuadratureRule{Ω, T}}, Tuple{T}, Tuple{Ω}} where {Ω<:AbstractDomain, T<:Real}","page":"API","title":"FiniteElementQuadratureRules.expand","text":"expand(cqr::CompactQuadratureRule{Ω,T})\n\nExpand a compact rule into a full quadrature rule. This first expands the symmetry orbits to generate a list of quadrature points and then computes the associated quadrature weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.getProperties-Tuple{AbstractDomain, AbstractVector, AbstractVector}","page":"API","title":"FiniteElementQuadratureRules.getProperties","text":"getProperties(domain::AbstractDomain, points::AbstractVector, weights::AbstractVector)\n\nCollect properties of a quadrature given as vector of points and weights. Currently, three properties are checked:\n\npositive weights: property :positive\npoints strictly inside the domain: property :inside\npoints are inside or on the boundary of the domain: property :boundary\n\nThe function returns a vector of properties as corresponding Symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.getProperties-Tuple{QuadratureRule}","page":"API","title":"FiniteElementQuadratureRules.getProperties","text":"getProperties(qr::QuadratureRule)\n\nCollect properties of a quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.getWeights-Union{Tuple{P}, Tuple{AbstractDomain, Integer, AbstractVector{P}, AbstractVector}} where P<:(AbstractVector)","page":"API","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector, orbits::AbstractVector)\n\nCompute the quadrature weight using Float64 precision.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.getWeights-Union{Tuple{P}, Tuple{AbstractDomain, Integer, AbstractVector{P}}} where P<:(AbstractVector)","page":"API","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector)\n\nCompute the quadrature weight using Float64 precision.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.getWeights-Union{Tuple{T}, Tuple{Type{T}, AbstractDomain, Integer, AbstractVector, AbstractVector}} where T<:Real","page":"API","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector, orbits::AbstractVector)\n\nCompute the quadrature weight associated to given quadrature points for quadrature in a given domain, such that polynomial up to degree are integrated exactly. This overload takes into account that the points are associated to symmetry orbits and thus points in the same orbit share a quadrature weight. This makes the computation more stable and faster. The parameter T represents the number type to be used for the computation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.getWeights-Union{Tuple{T}, Tuple{Type{T}, AbstractDomain, Integer, AbstractVector}} where T<:Real","page":"API","title":"FiniteElementQuadratureRules.getWeights","text":"getWeights(::Type{T}, domain::AbstractDomain, degree::Integer, points::AbstractVector)\n\nCompute the quadrature weight associated to given quadrature points for quadrature in a given domain, such that polynomial up to degree are integrated exactly. The parameter T represents the number type to be used for the computation.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.integrate-Tuple{Function, QuadratureRule}","page":"API","title":"FiniteElementQuadratureRules.integrate","text":"integrate(f::Function, qr::QuadratureRule)\n\nCompute the integral ∫f(x)dx over a domain Ω=domain(qr) using a quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.integrate-Union{Tuple{dim}, Tuple{FiniteElementQuadratureRules.BarycentricMonomials{dim}, AbstractSimplex}} where dim","page":"API","title":"FiniteElementQuadratureRules.integrate","text":"integrate(m::BarycentricMonomials, Ω::AbstractSimplex)\n\nCompute the integral of a barycentric monomial m over a generic simplex of volume 1. For a specific simplex, this integral needs to be scaled with its volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.optimize-Tuple{CompactQuadratureRuleWithWeights}","page":"API","title":"FiniteElementQuadratureRules.optimize","text":"optimize(qr::CompactQuadratureRuleWithWeights)\n\nOptimize the position of the quadrature points given as symmetric orbits in the compact rule, by minimizing the quadrature residual on a set of polynomial basis functions. We use basis functions and their integrals given by a JacobiPolySet.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.optimize-Tuple{CompactQuadratureRule}","page":"API","title":"FiniteElementQuadratureRules.optimize","text":"optimize(qr::CompactQuadratureRule)\n\nOptimize the position of the quadrature points given as symmetric orbits in the compact rule, by minimizing the quadrature residual on a set of polynomial basis functions. We use basis functions and their integrals given by a JacobiPolySet.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Dict-Tuple{QuadratureRule}","page":"API","title":"Base.Dict","text":"Dict(qr::QuadratureRule, ref::String = \"unknown\")\n\nConvert the given QuadratureRule into a Dict for exporting into a YAML file. The optional parameter ref refers to a bibtex key used to reference a publication where the quadrature rule is extracted from.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.AffineGeometry","page":"API","title":"FiniteElementQuadratureRules.AffineGeometry","text":"AffineGeometry{Ω,mydim,cdom,T} <: AbstractGeometry\n\nAn AffineGeometry is a parametrization using an affine map of the form x → A*x + b. As an AbstractGeometry it is itself a mapping.\n\nExample:\n\ngeo = AffineGeometry(ReferenceElement(Triangle()), [x0,x1,x2])\n@assert domaintype(geo) == Triangle()\nx = geo(λ)    # given λ in coordinates of the reference element\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.AffineGeometry-Tuple{AbstractVector}","page":"API","title":"FiniteElementQuadratureRules.AffineGeometry","text":"(geo::AffineGeometry)(λ::AbstractVector)\n\nEvaluate the affine geometry mapping geo in the reference element coordinate λ.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.BarycentricMonomials","page":"API","title":"FiniteElementQuadratureRules.BarycentricMonomials","text":"BarycentricMonomials <: Function\n\nA representation of a multi-dimensional monomial basis function of the form λ[1]^α[1] * λ[2]^α[2] * ... with λ the barycentric coordinate vector and α the exponents associated to the components of the coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.BarycentricMonomials-Union{Tuple{AbstractVector}, Tuple{dim}} where dim","page":"API","title":"FiniteElementQuadratureRules.BarycentricMonomials","text":"(m::BarycentricMonomials)(λ::AbstractVector)\n\nEvaluate the monomial basis function m in a given barycentric coordinate λ, i.e., compute λ -> λ[1]^α[1] * λ[2]^α[2] * ...\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.CompactQuadratureRule","page":"API","title":"FiniteElementQuadratureRules.CompactQuadratureRule","text":"CompactQuadratureRule{T,Ω}\n\nA compact (quadrature) rule is defined in terms of a vector of symmetry orbits and their corresponding arguments, which allows to generate a list of quadrature points in the reference element and also their corresponding quadrature weights.\n\nThe rule is defined on a domain, e.g., a triangle or quad, has an expected degree, which means the maximal polynomial degree up to which the quadrature rule is exact.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.CompactQuadratureRule-Tuple{Dict}","page":"API","title":"FiniteElementQuadratureRules.CompactQuadratureRule","text":"CompactQuadratureRule(data::Dict)\n\nConstruct a CompactQuadratureRule from parsed YAML/Dict data using Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.CompactQuadratureRule-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T<:Real","page":"API","title":"FiniteElementQuadratureRules.CompactQuadratureRule","text":"CompactQuadratureRule(::Type{T}, data::Dict)\n\nConstruct a CompactQuadratureRuleWithWeights from a YAML/Dict of strings and string arrays. This is a convenience constructor typically used when reading a quadrature rule from a YAML file. All information is encoded in the Dict, in particular the fields\n\ndim and region: characterizing the domain\ndegree: the quadrature degree\norbits: the symmetry orbits\npositions: representing the arguments to the symmetry orbits\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","page":"API","title":"FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","text":"CompactQuadratureRuleWithWeights{T,Ω}\n\nA compact (quadrature) rule with weights is defined in terms of a vector of symmetry orbits, their corresponding arguments, and a list of associated weights. This allows to generate a list of quadrature points in the reference element.\n\nThe rule is defined on a domain, e.g., a triangle or quad, has an expected degree, which means the maximal polynomial degree up to which the quadrature rule is exact.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights-Tuple{Dict}","page":"API","title":"FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","text":"CompactQuadratureRuleWithWeights(data::Dict)\n\nConstruct a CompactQuadratureRuleWithWeights from parsed YAML/Dict data using Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"API","title":"FiniteElementQuadratureRules.CompactQuadratureRuleWithWeights","text":"CompactQuadratureRuleWithWeights(::Type{T}, data::Dict)\n\nConstruct a CompactQuadratureRuleWithWeights from a YAML/Dict of strings and string arrays. This is a convenience constructor typically used when reading a quadrature rule from a YAML file. All information is encoded in the Dict, in particular the fields\n\ndim and region: characterizing the domain\ndegree: the quadrature degree\norbits: the symmetry orbits\npositions: representing the arguments to the symmetry orbits\nweights: for the quadrature weights\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.JacobiPolySet","page":"API","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet{Ω<:AbstractDomain,R<:Real}\n\nA JacobiPolySet represents a set of polynomials on a domain Ω in terms of a set of basis polynomials, hereby given as Jacobi polynomials. As an AbstractPolySet it provides also the integral values over the domain of all basis functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.JacobiPolySet-Tuple{AbstractDomain, Integer}","page":"API","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(domain::AbstractDomain, degree::Integer)\n\nConstruct a JacobiPolySet on the given domain of given polynomial degree, with Float64 as data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.JacobiPolySet-Tuple{Type, AbstractDomain, Integer}","page":"API","title":"FiniteElementQuadratureRules.JacobiPolySet","text":"JacobiPolySet(::Type, domain::AbstractDomain, degree::Integer)\n\nConstruct a JacobiPolySet on the given domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.LagrangePolySet","page":"API","title":"FiniteElementQuadratureRules.LagrangePolySet","text":"LagrangePolySet{Ω<:AbstractDomain,R<:Real}\n\nA LagrangePolySet represents a set of polynomials on a domain Ω in terms of a set of basis polynomials, hereby given as Lagrange polynomials. As an AbstractPolySet it provides also the integral values over the domain of all basis functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.LagrangePolySet-Tuple{AbstractDomain, Integer}","page":"API","title":"FiniteElementQuadratureRules.LagrangePolySet","text":"LagrangePolySet(domain::AbstractDomain, degree::Integer)\n\nConstruct a LagrangePolySet on the given domain of given polynomial degree, with Float64 as data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.LagrangePolySet-Union{Tuple{T}, Tuple{Type{T}, AbstractDomain, Integer}} where T","page":"API","title":"FiniteElementQuadratureRules.LagrangePolySet","text":"LagrangePolySet(::Type{T}, domain::AbstractDomain, degree::Integer)\n\nConstruct a LagrangePolySet on a given domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.MonomialPolySet","page":"API","title":"FiniteElementQuadratureRules.MonomialPolySet","text":"MonomialPolySet{Ω<:AbstractDomain,R<:Real}\n\nA MonomialPolySet represents a set of polynomials on a domain Ω in terms of a set of basis polynomials, hereby given as a monomial basis. As an AbstractPolySet it provides also the integral values over the domain of all basis functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.MonomialPolySet-Tuple{AbstractDomain, Integer}","page":"API","title":"FiniteElementQuadratureRules.MonomialPolySet","text":"MonomialPolySet(domain::AbstractDomain, degree::Integer)\n\nConstruct a MonomialPolySet on the given domain of given polynomial degree, with Float64 as data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.MonomialPolySet-Union{Tuple{T}, Tuple{Type{T}, AbstractSimplex, Integer}} where T<:Real","page":"API","title":"FiniteElementQuadratureRules.MonomialPolySet","text":"MonomialPolySet(::Type{T}, domain::AbstractSimplex, degree::Integer)\n\nConstruct a MonomialPolySet on a simplex domain of given polynomial degree, with T the data type used for the integral values.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.MultiLinearGeometry","page":"API","title":"FiniteElementQuadratureRules.MultiLinearGeometry","text":"MultiLinearGeometry{T,cdim,Ω} <: AbstractGeometry\n\nA MultiLinearGeometry is a geometry mapping defined in terms of linear Lagrange basis function associated to the domain Ω. It can be constructed from a reference element and a vector of corner coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.MultiLinearGeometry-Tuple{AbstractVector}","page":"API","title":"FiniteElementQuadratureRules.MultiLinearGeometry","text":"(geo::MultiLinearGeometry)(λ::AbstractVector)\n\nEvaluate the multilinear geometry mapping geo in the reference element coordinates λ, by linear combination of the associated Lagrange basis functions and corner vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.MultiLinearGeometry-Union{Tuple{T}, Tuple{cdim}, Tuple{Ω}, Tuple{ReferenceElement{Ω}, Array{StaticArraysCore.SVector{cdim, T}, 1}}} where {Ω<:AbstractSimplex, cdim, T<:Real}","page":"API","title":"FiniteElementQuadratureRules.MultiLinearGeometry","text":"MultiLinearGeometry(ref::ReferenceElement, coordVector::AbstractVector)\n\nConstruct a MultiLinearGeometry as an affine geometry if the domain is a simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.QuadratureRule","page":"API","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule{Ω,T,Point}\n\nA QuadratureRule on a given domain Ω is a collection of points {xᵢ} in the associated reference element and weights {wᵢ}, such that for a given polynomial p the quadrature formula ∑ᵢ p(xᵢ) wᵢ = ∫p(x) dΩ is exact, up to polynomials of a certain degree.\n\n\n\n\n\n","category":"type"},{"location":"api/#FiniteElementQuadratureRules.QuadratureRule-Tuple{Dict}","page":"API","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(data::Dict)\n\nConstruct a QuadratureRule from parsed YAML/Dict data using Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.QuadratureRule-Union{Tuple{Point}, Tuple{AbstractDomain, Integer, Vector{Point}}} where Point<:(AbstractVector)","page":"API","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(domain::AbstractDomain, degree::Integer, points::Vector)\n\nConstruct a new QuadratureRule and compute the weights and properties of the rule automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.QuadratureRule-Union{Tuple{T}, Tuple{Point}, Tuple{AbstractDomain, Integer, Vector{Point}, Vector{T}}} where {Point<:(AbstractVector), T<:Real}","page":"API","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(domain::AbstractDomain, degree::Integer, points::Vector, weights::Vector)\n\nConstruct a new QuadratureRule and compute the properties of the rule automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.QuadratureRule-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"API","title":"FiniteElementQuadratureRules.QuadratureRule","text":"QuadratureRule(::Type{T}, data::Dict)\n\nConstruct a QuadratureRule from a YAML/Dict of strings and string arrays. This is a convenience constructor typically used when reading a quadrature rule from a YAML file. All information is encoded in the Dict, in particular the fields\n\ndim and region: characterizing the domain\ndegree: the quadrature degree\ncoordinates: representing the quadrature points\nweights: for the quadrature weights\nproperties: characterizing properties of the quadrature rule\n\n\n\n\n\n","category":"method"},{"location":"api/#FiniteElementQuadratureRules.ReferenceElement","page":"API","title":"FiniteElementQuadratureRules.ReferenceElement","text":"ReferenceElement{Ω,Point}\n\nA reference representation of a given domain Ω in terms of corner coordinates and a list of facets connecting the corners.\n\n\n\n\n\n","category":"type"},{"location":"#FiniteElementQuadratureRules","page":"Home","title":"FiniteElementQuadratureRules","text":"This julia package allows to transform compact quadrature rules, given in terms of symmetric orbits of points inside reference domains, like simplices and cubes, into full sets of quadrature points and weights. Additionally, the package provides utilities to improve the accuracy of given quadrature rules, by running an optimizer with high floating point accuracy, starting from the given set of points as initial condition.","category":"section"},{"location":"#Main-workflow-for-FE-library-developers","page":"Home","title":"Main workflow for FE library developers","text":"The primary goal is to support finite-element library developers who maintain stored quadrature rules:\n\nread compact rules from rules/compact/...,\nexpand to full coordinates and weights,\ntransform coordinates/weights to the target reference-element convention,\ngenerate library-specific code from a template.\n\nThe repository includes a template for Dune in dune.templ.hh.","category":"section"},{"location":"#Expand-compact-rules","page":"Home","title":"Expand compact rules","text":"A compact rule describes symmetric orbits and orbit parameters. Expansion yields explicit quadrature coordinates and weights.\n\nExample:\n\nusing FiniteElementQuadratureRules\nusing YAML: load_file, write_file\n\ndata = load_file(\"rules/compact/CCGV22/triangle/4-6.yml\")\ncqr = CompactQuadratureRule(BigFloat, data)\nqr = expand(cqr)\n\nmkpath(\"rules/expanded/CCGV22/triangle\")\nwrite_file(\"rules/expanded/CCGV22/triangle/4-6.yml\", Dict(qr; reference=data[\"reference\"]))","category":"section"},{"location":"#Transform-to-another-reference-element-convention","page":"Home","title":"Transform to another reference-element convention","text":"Finite-element libraries may define different reference-element coordinates for the same topological domain. Use transform to map rules between conventions.\n\nExample (to Dune triangle convention):\n\nusing FiniteElementQuadratureRules\nusing YAML: load_file\n\ndata = load_file(\"rules/compact/CCGV22/triangle/4-6.yml\")\nqr = expand(CompactQuadratureRule(Float64, data))\n\nref_in = ReferenceElement(Triangle())\nref_dune = duneReferenceElement(Triangle())\nqr_dune = transform(qr, ref_in, ref_dune)","category":"section"},{"location":"#Generate-library-specific-code-from-templates","page":"Home","title":"Generate library-specific code from templates","text":"generate renders source/header files from an Otera template with rule data grouped by domain and degree.\n\nExample (Dune):\n\nusing FiniteElementQuadratureRules\n\ngenerate(\"dune.templ.hh\", \"rules/compact/CCGV22/\", \"dune/\"; precision=80)","category":"section"},{"location":"#Optional:-optimize-rule-accuracy","page":"Home","title":"Optional: optimize rule accuracy","text":"Improving rule accuracy is an additional feature. Use it when published coefficients are low precision and you need a high-precision variant.\n\nusing FiniteElementQuadratureRules\nusing YAML: load_file\n\ndata = load_file(\"rules/compact/CCGV22/triangle/4-6.yml\")\ncqr = CompactQuadratureRule(BigFloat, data)\noqr = optimize(cqr)","category":"section"}]
}
