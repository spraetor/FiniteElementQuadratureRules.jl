
@testset "Jacobi" begin
  for n in 0:5
    for a = 0:5
      for b in 0:5
        @test jacobi(n,a,b,1.0) == binomial(n+a,n)

        X = range(-1,1,7)
        @test jacobi(n,a,b,X) ≈ map((x) -> jacobi(n,a,b,x), X)
        @test jacobi(n,a,b,-X) ≈ (-1)^n .* jacobi(n,b,a,X)

        if n > 0 && b > 0
          @test (2n+a+b).*jacobi(n,a,b-1,X) ≈ (n+a+b).*jacobi(n,a,b,X) .+ (n+a).*jacobi(n-1,a,b,X)
        end
      end
    end
  end

  let tri = Triangle()
    cqr = CompactQuadratureRuleWithWeights(tri, 5, [0,4,3],
      [ 0.00000000000000000000000000000000000,
        0.05752768441141010566081751776543190,
        0.25685910726195907606389083148220168,
        0.45783683807916110193850321742406830,
        0.00000000000000000000000000000000000,
        0.36329807415368604570550633618418105,
        0.00000000000000000000000000000000000,
        0.13226458163271398535388822004364736,
        0.22100121875989000797812820146484192,
        0.07819258362551702199888597846982583 ],
      [ 0.00141884794135849195859201314216757,
        0.02325227091923514227899684743112030,
        0.09180247526152571475403829582713371,
        0.06906086075456558705677702806082523,
        0.01238113000735325822823625385145974,
        0.00696115728097842131688535505330661,
        0.05455715193999251909734296553127691 ])
    qr = expand(cqr)

    for degree in 0:5
      jac = JacobiPolySet(tri, degree)

      @test jac.integrals ≈ map(f -> integrate(f, qr), jac.basis)
    end
  end
end